2/20/16

http://www.mattgreer.org/articles/a-game-made-with-reagent/ talks about using css animations; TODO

https://rafalcieslak.svbtle.com/9-tips-for-clojurescript-beginners has a few good links
mentions checkout dependencies

======

2/21/16

https://developer.mozilla.org/en-US/docs/Games/Techniques/Efficient_animation_for_web_games
****** this article appears to be super good
has tips on how to avoid drawing things multiple times per frame (which would be a waste)
mentions https://github.com/BernieSumption/animator.js which is super old
cf http://blog.berniesumption.com/software/animator/
" For a modern library that exposes CSS animations through a similar API, I recommend jQuery.Transit."
so maybe the mdn article above is real out of date?

https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame

anyway tbh i think i should probably be using canvas instead of svg for a bullet-hell shooter/rpg
i think reagent+svg/divs/whatever makes tons of sense for turn-based games like cljstone
but for a boi clone, it really seems like square peg round hole

css/svg/etc animation links for later if i end up wanting them:
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions

anyway overall it looks like css transformations/animations are useful for situations where, like,
you've got a particular UI that you want to animate - but i don't think they're at all relevant for
a game in a web browser, it just doesn't make any sense

re: reagent and canvas (already expected these two wouldn't work together):
https://www.reddit.com/r/Clojure/comments/3cq5hg/can_reagent_components_work_with_html_canvas/
"No, and I've tried: https://github.com/gzmask/embodier-gcode-webgl"


canvas resources:
https://github.com/rm-hull/monet [seems abandoned; TODO read anyway, might have good ideas]

core.async and keyboard events: https://github.com/bdrillard/async-key-events

had trouble getting access to goog.events.KeyCodes, was given
http://clojurescriptmadeeasy.com/blog/when-do-i-use-require-vs-import.html in slack

TODO what the hell is an entity component system
https://github.com/markmandel/brute
https://github.com/muhuk/clecs
https://github.com/weavejester/ittyon

TODO what is http://wercker.com/

http://hueypetersen.com/posts/2016/02/13/om-next-from-a-relay-graphql-perspective/
incomprehensible om.next/relay/redux/graphql post

https://eklitzke.org/effectively-using-bash-profile evan notes on .bash_profile vs .bashrc

http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/ core.async implementation
http://hueypetersen.com/posts/2013/07/10/code-read-of-core-async-timeouts/ also good post on timeout!

http://hueypetersen.com/posts/2013/06/17/angular_is_slow/ - unrelated, but good quote:
"Your model is not your view model. It can be for simple cases, but as soon as you start feeling
friction you want to let the view model evolve instead of changing your domain models to suit the view."
****** gold stuff

ok so what is https://github.com/pedestal/pedestal
i remember this being announced at clojure/west a while back but don't know anything about it
lol "Our primary focus for the near future is Pedestal documentation, sample applications and
improving general ease of use."
so i think i can be forgiven for closing this tab and checking back later
https://github.com/pedestal/pedestal/tree/master/guides/documentation for the record

edmund says to use https://github.com/edmund-huber/sssgen for my blog
i'm sure he's not biased

https://en.wikipedia.org/wiki/Entity_component_system - see "game example" section
really good info
one of the main touted advantages is "composability instead of inheritance" - so is ECS still relevant in cljs?
the description of components sounds a lot like clj/s protocols

https://stackoverflow.com/questions/1901251/component-based-game-engine-design
the guy in that answer says use FRP instead of ECS

https://web.archive.org/web/20140719094839/http://www.altdev.co/2011/10/08/a-handful-of-components/
********* good shit
"The health component is probably the component that I re-use the most. Not just a health value that goes up
and down it also keeps track of invulnerability, regeneration and poison. It also looks after the entities
damage modifies with the following types currently supported Fire, Ice, Melee, Projectile, Magic and Crushing"

notes before i forget

what does game state end up looking like? do we end up adopting some ecs concepts and going with like

state: {:entities [Entity]}
Entity: {:id s/Int
         :components [Component]}

having an id helps for generating ^keys
what do rooms look like? are they some sort of, like, container components?
or do we have an :entities list and a :rooms list? the player's only in one room at a time if that's relevant

=======

2/22/16

https://www.youtube.com/watch?v=9sc8Pyc51uU
******* great talk on graphql / relay

https://github.com/devknoll/graphql-resources graphql links

https://www.youtube.com/watch?v=UoZyyo2Bwr8 talk on hoplon/javelin
difficult to tell how to reason about it with regard to reagent
he trashtalks the virtual dom for a while but i don't think all his criticisms apply
not a super big fan of the tone of this talk in general, the tech looks useful but not much different from reagent

reading https://github.com/evancz/elm-architecture-tutorial/

TODO for boi what will movement look like? does a player have a :bounding-box {x y width height} and a
:movement-state [:down :right]? that could work.

at some point i want to read the react dom-diffing code but i have 600 other tabs to process first

ok time for http://elm-lang.org/guide/reactivity
"Note: It is usually best to use signals as little as possible. When it comes to writing nice modular code,
you should primarily use normal functions and values. If you find yourself stuck with a signal of signals,
ask yourself “how can I model this explicitly with functions and values?”"

https://www.reddit.com/r/elm/comments/3s6lhb/learning_elm_vs_haskell_as_an_intro_to_functional/ elm vs haskell

reading http://elm-lang.org/blog/blazing-fast-html
"Virtual DOM sounds pretty slow, right? Create a whole new scene on every frame? This technique is actually
widely used in the game industry and performs shockingly well for DOM updates when you use two relatively
simple techniques: diffing and laziness." *******

"game industry" phrase links to https://en.wikipedia.org/wiki/Scene_graph

https://pchiusano.github.io/2014-07-02/css-is-unnecessary.html advocates using a lang like elm instead of css
"A little reflection on the history of software reveals abstraction as the primary means by which humans
make increasingly complex software possible and comprehensible."

https://news.ycombinator.com/item?id=9797973 om rant thread


************
okokok here's what i want to build
bullet-hell, twin-stick, top-down, boi-style combat/gameplay (except tear height, fuck that)
boi-style items
diablo-style levels (randomly generated floors rather than rooms; hallways, forests, whatever)
simple RoR-style leveling (don't care about skill trees / talents, just want to avoid staying at base damage
  forever like you often do in BoI)

updated state sketch
state: {:entities [Entity]
        :mode (s/enum :menu :loading :normal :etc)}
Entity: {:id s/Int
         :type (s/enum :player :bullet :monster :wall :etc)
         :components [Component]}

************

elm architecture notes:
https://gist.github.com/evancz/2b2ba366cae1887fe621
talks about advantages of having a centralized home of application state - single source of truth


what does main game loop look like?
*****
`
update-movement-state ; let monsters decide to aggro, leash, change their direction, etc
update-movement-speeds ; update dx, dy
update-positions ; update x, y (should we combine this with update-movement-speeds? unclear)
update-status-effects ; poison, invincibility, etc
calculate-collisions
update-health (? or does calculate-collisions do this? what does calculate-collisions do? add to a queue of
  unresolved collisions? something else?)
perform-attacks (player and monsters can have an :attacking state, with an :attacks-per-second or something)
`
******
what else?
can these things be done in parallel? how?
i guess you could have each use pmap instead of map, that could work pretty well actually

what does poisoning look like? a PoisonComponent and a poison-system?
maybe StatusEffects and an apply-status-effects system
i kinda like that a lot actually

bullets can't collide with other bullets
so there's an Owned component maybe

interesting notes on virtual dom / diffing: https://gist.github.com/Raynos/8414846
http://calendar.perfplanet.com/2013/diff/
good notes on setState effects, dirtiness setting, etc

http://t-machine.org/index.php/2012/03/16/entity-systems-what-makes-good-components-good-entities/
lots of example entities, components, systems

"Ideally, you add a new component when you have a new “dimension” to the game objects. For instance,
if you’re adding a physics System, you may not need to add any new Components – it might be that all
you need is Location (containing x,y,x position and dx,dy,dz velocity) and RenderState (containing
screen-pixels x,y) – and that you already have those components."

***** note re xyz position, dxdydz velocity ******

note warnings re: "Many systems per component" being a warning sign
the two versions of badness listed:

You have – say – 8 variables in the struct where you should instead have two structs (components),
one with 5 variables, the other with 3.
You have – say – 4 variables in the struct, but different systems are using those variables to mean
different things. It works OK for now, but it’s very fragile – as soon as the different meanings
diverge even a little, your code is going to start breaking

goood shit in this article man

in the comments:
"In regard to components a good idea at times is to stuff as much data into a single component that
covers the complete purpose. This cuts down referencing multiple components over and over and there
is definitely a speed up in a tight loop. A good example of this is physics where in my efforts I
provide a default “KinematicsParams” component that has velocity, position, rotation, angular velocity,
angular rotation, etc. etc. all stuffed into one data component. The reason being is that instead of
referencing a single component for each parameter it’s much easier / quicker to reference one."

"Q: What are the thoughts about having components that dont have any data, but instead exists to label
a entity in a way. A: I’m all for it."

http://t-machine.org/wp-content/uploads/Aliqua-progress-2015-BUUG-v3.pdf describes entity systems

via http://entity-systems.wikidot.com/ -
Entity - A container into which components can be added,
  ****usually hierarchical (any Entity can have sub-Entities).****

"Whereas in an inheritance-based design, an enemy may have a complex inheritance chain such as
Damageable <- Actor <- GroundBasedActor <- Enemy <- ZombieEnemy, in a C/ES-based design you might
have a Health component, a GroundBasedMovement component and a ZombieAi component added to
an entity named ZombieEnemy."

"Rendering and updating may take place either by traversing the entire entity tree (slow), by
having entities register themselves to the respective services (service locator hell) or in a
hybrid approach where the renderer/clock system remember which components they found in the tree
while entities merely provide a change notification if components are added to them or removed
from them, allowing the renderer/clock system to re-check that part of the tree (complex).
This aspect of the design is however not part of the C/ES pattern."

http://t-machine.org/index.php/2007/11/11/entity-systems-are-the-future-of-mmog-development-part-2/
definition of entities/components
"For every discernible “thing” in your game-world, you have one Entity. Entities have no data and no methods."

all this stuff is very clojure-y - clear separation + composition of data and behavior
"Typical Systems in a game would be: Rendering System, Animation System, Input System, etc.
 The Rendering system wakes up every 16 milliseconds, renders every Entity that has the Renderable
 Component, and then goes back to sleep."

"But the vast majority of game development is orders of magnitude more complex than Chess.
If you try – for instance – to write a computer game of Chess, that has AI … you certainly
don’t have “a movement and position component”.
Instead, you have: movement, position, potential positions this turn, potential positions on
future turns, threat radius, threatened squares, tactical options, strategic options, available
“plays” (famous chess strategies), enemy-histories-per-piece (what does your opponent tend
to do with pawns?) … etc."

http://t-machine.org/index.php/2007/12/22/entity-systems-are-the-future-of-mmog-development-part-3/
"So, don’t be tempted into hierarchical encoding, and definitely don’t do ANY encoding in the entity names"
“a System essentially provides the method-implementation for Components”.

components - data
systems - behavior
entities - id'd collections of data

"Mathematically-speaking, an Entity is a database Key, just as you’d see in any RDBMS.
Likewise, from a purely abstracted point of view, the “set of component-instances that comprise
Entity #7742” is, literally, a database Query.
THIS is why I said at the start that, ideally, you do NOT want to store your component-instances
as a list inside a struct/class representation of each Entity. Fundamentally, that set is NOT
defined as a list (a list is a static thing, it’s members don’t change without you changing them),
it’s defined as a query (whose members are always changing, whether you want them to or not),
and using one where really you wanted the other tends to cause problems in the long term."

hm - does all that still apply in clojure-land?
yeah prob not he says this is mainly for giant server-side games, which makes sense but
won't be super relevant for my tiny little client-side game

http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/
good article, not much different from the stuff above in t-machine
does have stories about introducing this design architecture into a preexisting system, neat

"Ideally, components should not know about each other. However, in a practical world, there
are always going to be dependencies between specific components. Performance issues also
dictate that components should be able to quickly access other components. Initially we had
all component references going through the component manager, however when this started using
up over 5% of our CPU time, we allowed the components to store pointers to one another, and
call member functions in other components directly."
hrm

http://scottbilas.com/files/2002/gdc_san_jose/game_objects_slides.pdf
"– Examples are trees, bushes, monsters, levers, waypoint markers, doors, heroes, inventory items
 – Many are “pure logic”, never see them (triggers, elevator movers, camera sequences)"

======

2/23/16

https://news.ycombinator.com/item?id=5116615 rant on ECS / clojure performance for games
fuck this guy tho

anyway i had a lot of ideas re: game this morning, jotting them down

current favorite name: voke (as in invoke, evoke, voco)

things i like about teleglitch:
punishing difficulty
setting/aesthetic (irrelevant, i'm not doing much art design here)
general terror about what's around the next corner
not so much into the crafting system, but was a fan of the health / armor system

bullets should be rectangular and thinnish rather than squares

if we end up making levels with hallways, i'm worried about the player cheesing the game by just
  funnelling all enemies through a hallway and shooting at them
i guess just don't have hallways?
what about doorways though?
i guess just have all doorways be way bigger than the player's/monsters' hitboxes, so monsters can always
  chase through really quickly

http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/
super good article
sort of unclear how to apply it to cljs tho

TODO - are deftypes/etc more performant than maps in cljs?

*****************
http://t-machine.org/index.php/2013/05/30/designing-bomberman-with-an-entity-system-which-components/
******* good shit
****** fuckin gold
"…if data should be in two components, but you can’t decide which: create a third component for it"
ok let's move all this stuff over to a new repo so i can start taking detailed game notes

ok per that post

behaviors:
move a player/monster/bullet in the direction is velocity indicates
player/monster runs into a wall, can't go farther in that direction
player/monster fires a bullet up/down/left/right
move a bullet along its vector
bullet collides with a player/monster, disappears, decrements health
monster/player collide, decrement player health
kill a player/monster
monster decides to aggro or leash
player/monster decides to change direction
player/monster decides to want to attack in a particular direction
player uses an active item
player picks up an item
camera moves to follow the player

data:
player/monster/bullet/wall collision-box
player/monster/bullet dx/dy velocity
player/monster/bullet top speed / acceleration
player intended move direction (8 options)
player intended fire direction (8 options)
monster intended move direction (360 degrees)
monster intended fire direction (360 degrees)
player/monster health
player armor
player xp
player/monster level
player inventory
player/monster bullet effects
bullets in flight
bullet owners
player/monster attack state [range, frequency, time since last shot]
item name and effect
camera
background


TODO how to take keyboard wasd/arrow input?

TODO look into public domain sprites for players/monsters/bullets/whatever

http://t-machine.org/index.php/2013/05/30/designing-bomberman-with-an-entity-system-which-components/comment-page-2/#comment-1274479
really great question
never gets an answer!

http://t-machine.org/index.php/2013/05/30/designing-bomberman-with-an-entity-system-which-components/comment-page-2/#comment-1274784
**********

http://t-machine.org/index.php/2012/04/19/concepts-of-object-identity-in-game-programming/
******* has notes on how systems can communicate with one another
eg kill enemy, enemy drops loot

*********
http://shaun.boyblack.co.za/blog/2012/08/04/games-and-entity-systems/ other guy's list of components/etc
******** GREAT post

http://www.richardlord.net/blog/what-is-an-entity-framework
ECS vs game loop
not much new info after i've read all the stuff linked above, but overall a great standalone post
"The collision system, which tests whether the player is colliding with other objects and
resolves those collisions."

"The systems are decoupled form each other. Each system knows only about itself and the data
it operates on. It knows and cares nothing at all about the other systems and how they may
have affected by or used the data before or after this system gets to work with it."
hm, discourages systems from communicating

but later...
"In most games, ***some*** of the systems are entirely independent of each other, including being
independent of the order in which they are applied. This makes it easy to run these systems in parallel."

anyway i mean i've been reading a bunch of this stuff and it's all cool and helpful but i'm not sure
how much of it applies in clojureland. in clojure you'd just be passing maps around to different functions
anyway, you'd have a clear separation of code and data, which is what ECS is all about.
so at the end of the day the main distinction is between, like, do i have game objects like this?

{:id 123
 :type :player
 :position a-position
 :velocity a-velocity
 :intended-movement-state an-intended-movement-state
 :firing-state a-firing-state
 etc
}

or do i have objects like this:

{:id 123
 :components [player-controlled, a-position, a-velocity, an-indended-firing-state]
}

ECS is all about the second option i think, although it's sort of six-one-half-dozen-other, maybe doens't matter.
might as well give it a shot

TODO - what does player-controlled look like? does it contain both intended movement direction
  and intended firing direction? what about active item usage, how does that work?

http://gameprogrammingpatterns.com/component.html
****** has a section on how components communicate with one another!!!!!!

"sending messages" - sounds familiar

so i guess the idea proposed here is that entities have a "send" function, and components have a
"receive" function
i mean that's all pretty OO
in clj, it'd probably look more like

(messaging/send an-entity-id a-message)

that seems reasonable

but what does it end up actually doing? like let's say we do
(messaging/send 1234 {:type :player-direction-input
                      :value :UP})

where does the code live that handles that message?
i guess you let components subscribe to specific types of messages and have some sort of "bus"
(what does that term even mean?) that coordinates all this; i know core.async has facilities along these lines

hm hm hm

"Some domains are distinct but still closely related. Think animation and rendering, user input
and AI, or physics and collision. If you have separate components for each half of those pairs,
you may find it easiest to just let them know directly about their other half.

Messaging is useful for “less important” communication. Its fire-and-forget nature is a good
fit for things like having an audio component play a sound when a physics component sends a
message that the object has collided with something."

hm i'm not sure about the messaging/send stuff from above

ok so what about if like for instance the physics component just adds a PendingAudio component
and the audio system looks for PendingAudio components on each tick, plays them, and removes them

and so the velocity component directly reads from the player-input component

and the player-input component is... directly sent messages via the UI?
hm how does it get its stuff

i guess the game's business logic is a module that has a clearly defined API
and only has a few specific public functions

(accept-player-input a-message)
(let-time-pass time-delta)

and so accept-player-input is a function that under the hood modifies components, and even then
just like the direction the player is intending to move and fire

and also i guess like (pause-game) etc

so what does the game's state currently look like?

{:entities [Entity]
 :mode Mode ; for pausing, menus, game over, whatever
 :active-level an-entity-id ;?
 ; maybe a channel but probably not, it can be local to the root reagent component
}

https://gamedev.stackexchange.com/questions/31473/what-is-the-role-of-systems-in-a-component-based-entity-architecture/31491#31491
not sure about the metaphor, but the main message is that systems can read from multiple components at once
*** for perf, it suggests having each entity have a bitfield indicating which components it has; that could work

https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/levels/first.cljs
**** level built in clj with an ECS
"In ChromaShift's case the core structure and caches for the engine are actually written in
JavaScript for performance reasons, while all of the game CES is written in ClojureScript."

http://www.clojure-games.org/component-entity-system

https://github.com/muhuk/clecs-examples/blob/master/clecs-example-roguelike/src/clecs_example_roguelike/entities.clj
example entities/components

i like https://github.com/muhuk/clecs/blob/master/src/clecs/system.clj -
rather than having systems just be functions, he has them be maps
so in addition to a function that takes a world and returns a new one, he has other metadata too like
:name :rendering
:reads #{:Inventory :Renderable}
:writes #{:Inventory :Location}
interesting! overkill or helpful/necessary?

http://alexkehayias.tumblr.com/post/78711349238/entity-component-model-in-clojurescript
ecs with protocols/records

https://github.com/alexkehayias/chocolatier/ yet another system that talks a lot about:
"Think about it less as a bunch of objects with their own state and methods and more like
a database where you query for functionality, state, based on a certain aspect or entity."

i've seen this talk of databases+queries like 10 times now in reference to ECS, not sure
what i think about it

chocolatier has notes about cross-component communication
"A global pub-sub event queue is available for any component enabling cross component communication
without coupling the state of any of the components. For example, suppose the render component
needs to update the screen position of the player sprite. The render component needs information
from the input component, but we don't want to couple the state of either components together.
Instead of directly accessing the input component's state from the render component we subscribe
to messages about player movement and update based on that. We can broadcast that information without
any knowledge of who is listening to it and no one can change the component state from another component."

not sure i 100% agree with the components he's come up with, but anyway here's another bit of precedent
for messages / pubsub

"Any component can subscribe to events by creating a component with a :subscriptions key in the options
hashmap where each subscription is a vector of selectors:
 (mk-component state :player1 [component-f {:subscriptions [[:e1] [:e2]]}])
The subscribed component will receive the event in a hashmap in the :inbox key passed in as the
third argument to the component function. Messages that are sent are available immediately to
the subscriber which allows for events to be sent and received within the same frame and are
therefore order dependent."

interesting

"ClojureScript presents challenges for optimization including garbage collection, persistent
data structures, and functional paradigms that js engines may have difficulty optimizing."
eep

"Where appropriate, transient state should be used when operating on large collections and
hashmaps for better performance. See chocolatier.macros in the clj source directory for
helpers with transient state. "

re: performance
https://stackoverflow.com/questions/21721028/how-to-improve-clojurescript-performance
"Now, if performance is really critical to what you're doing and persistence provides
no benefit, you can just use arrays and objects from ClojureScript:"
"By using records and native field access, you can cut the runtime for your
original ClojureScript solution in half"

http://numergent.com/2015-12/ClojureScript-performance-revisited.html
******
"As we can see it’s doing this with a regular vector, which we can easily turn into a
transient one and persist it once we’re done."
bought him 1 fps, 12->13
lists other, more impactful techniques
mentions `keep` as a one-pass map+filter

http://davedellacosta.com/cljs-protocols notes on protocols

http://www.bestinclass.dk/blog/brians-brain-optimized-clojurescript-html5

https://swannodette.github.io/2013/06/10/porting-notchs-minecraft-demo-to-clojurescript/ nolen on perf

okok that's enough reading for now
tomorrow i should be able to start actually coding something
and constantly be terrified that i'm violating all the principles i've read about or some shit

TODO look into a good canvas js library that i can use via cljsjs

https://web.archive.org/web/20140509212857/http://resatori.com/clojure-entity-component-system

unrelated: http://yogthos.net/posts/2016-02-22-LuminusEmbracingHugSQL.html - yesql no longer developed?

http://elbenshira.com/blog/the-end-of-dynamic-languages/
http://yogthos.net/posts/2015-11-28-TheSkyIsNotFalling.html
dunno about this argument

http://retroaktive.me/blog/keechma-design-decisions/

https://github.com/tonsky/datascript - relevant for storing entities?

======

2/24/16

ibdknox uses a js stats library in https://github.com/ibdknox/ChromaShift/blob/master/js/lib/stats.js
see https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/lib/dev.cljs

he uses ! and ? as aliases for aset and aget, not sure if i like it but here we go
https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/lib/core.cljs

physics in https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/lib/physics.cljs
note the Box2D library he seems to be using

ok you know what i think my entities are just going to look like

{:id 1234
 :type :player
 :position a-position-component
 :bounding-box a-bounding-box-component
 :etc etc}

rather than

{:id 1234
 :components [a-position-component a-bounding-box-component etc}

i think that the second style makes a lot of sense if you're outside of clojure and are used to OOP and
trying to force yourself out of it, but i don't think it's required here. i also think that the second
style is particularly good about discouraging components from communicating with one another, and also
that it probably makes a lot of sense in eg an MMO where you have a jillion entities and a jillion components
and you want to store their relationships in a RDBMS. but that's not us here. so i think i'll just use dicts.

http://box2d-js.sourceforge.net/ here's that box2d library
more relevant if you want gravity, etc; let's skip it imo

still having a lot of trouble figuring out what position components should look like
are they just an :x and a :y, or do they also have a :width and a :height?
i know that ideally :width and :height would be for bounding boxes, but like what *doesn't* have a shape like that?
i think in this game i'm going to have everything be rectangular, so nothing
so you have a :position with an :x and a :y and a :width and a :height
and you can also optionally have a CollisionBox with a :width and a :height
things that don't have collision boxes: scenery, basically nothing else
end of level has a collision box so you know when the player's walked into it
items/pickups have collision boxes for same reason
so i guess collision boxes have some sort of like :obstruction true/false field

seriously do look into that stats.js thing, it looks legit
https://github.com/mrdoob/stats.js/
note the bookmarklet!!!!

ok cool this bookmarklet works:
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();stats.domElement.style.cssText='position:fixed;left:0;top:0;z-index:10000';document.body.appendChild(stats.domElement);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)}); document.getElementById("ms").style.display="block"; document.getElementById("mb").style.display="block";};script.src='http://rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

lots of notes from my walk, going to try to get them all down before i forget them
you have a few systems that run every tick
movesystem, firesystem
they read from intended-move-direction and intended-fire-direction
which for human-controlled entities is written to directly by the keyboard (via an interface)
and for AI entities is recalculated every tick [so there's another one that's run every tick]

but most of your systems just listen to events
collisionsystem listens for intended-move messages
damage system listens for contact messages
xp system listens for kill messages
etc

and so you have this like event graph / dependency graph between the systems
and so you have a few that are running every tick, and most of them always running and just listening
for events constantly
and the rendering system runs every tick too


unrelated
status effects:
poison
freeze
knockback
slow
stun (same as freeze?)

okok so we're almost ready to get started but first i want to make sure my ideas about events + ECS
aren't completely insane, so i have a bunch of google tabs open about that

https://github.com/MovingBlocks/Terasology/wiki/Entity-System-Architecture talks about events
cool-looking project btw, voxel world thingy

"ComponentSystems, or Systems for short, provide behavior to entities. They do this in two ways
Processing entities with a desired set of components in response to engine method calls like
initialise(), update(float delta) and render()
Responding to entity events sent to entities with a desired set of components"

yeah, that sounds kinda like what i have in mind, cool

"The health system would respond to an entity with a Health component receiving a Damage event,
in order to reduce an entity's health - and if the health reaches 0, send a Death event to the entity"

in this design of theirs, *entities* receive events rather than systems receiving events. not sure if
i agree with this, prob won't do that

https://github.com/MovingBlocks/Terasology/wiki/Entity-System-Architecture#events-and-event-handlers good shit

" Systems can then provide event handlers to pick up specific events that have been sent entities
with a desired set of components. Expanding on the Damage event, you may have a System that handles
damage events that occur on entities with health components, in order to reduce health. Or a System
that handles damage events for entities with a location and physics component, to knock the entity
away from the damage causer."

i'm still not convinced that sending messages to entities is correct

"Events also support cancellation - this allows a system to stop an event before it
eaches systems with a lower priority - for instance if you add an invincibility component
to make an entity temporarily immune to damage, you can add a system that will intercept
the Damage event and cancel it before it can reach the health system."

hrm hrm hrm

https://www.gamedev.net/topic/643311-events-and-entity-component-systems/
good first post, bad responses

https://gamedev.stackexchange.com/questions/47476/tips-for-component-based-entity-system-message-handling
"Although I haven't implemented a way to handle events (other than entity-related events),
I left that up to the user" lol

https://gamedev.stackexchange.com/questions/83767/communication-pattern-in-entity-component-system
"There is no right answer to your question and a lot of it comes from personal taste and out of need."
fair nuff

http://unity-coding.slashgames.org/component-based-entity-systems-event-driven-systems-to-implement-the-logic/
"As a system is very self-contained, events are the way to communicate with other systems and the world
outside a system in general."
yes yes fine ok

http://forums.xkcd.com/viewtopic.php?f=11&t=81459
"the major strength of component systems: you minimise communication overheads and you can easily "batch" updates."

http://tarheadstudio.com/entity-component-system/
"Have you considered an event system of some sort on top of this?"
"Yes. The way we have solved it is rudimentary though: systems send messages, which is an object with
some data, to a game manager, who propagate the message to every other system."

ok so at this point i'm convinced that my design is good

******
so we're going to go with the style of entities/components that i talked about at the start of today's notes
and there will be a bunch of systems that exist
and some systems will run on every tick
and other systems will just listen for events
and there are some examples of those two kinds of systems in today's notes above
rad

https://github.com/tonsky/41-socks/blob/gh-pages/src/forty_one_socks.cljs

http://www.compoundtheory.com/ prettiest blog ever
http://www.compoundtheory.com/brute-entity-component-system-library-0-2-0-the-sequel/
started side-effecty, went functional
ok so anywyay i'm not going to use brute

http://www.compoundtheory.com/writing-a-game-feels-like-im-going-around-in-circles/
TODO free sprites at http://www.widgetworx.com/spritelib/
apparently http://www.physicsclassroom.com/ is good for physics

http://www.compoundtheory.com/mini-game-dev-diary-1/ cool stuff

http://www.pixijs.com/ claims to be super fast

ok so i need to pick a rendering library
first contenders i found are phaser, fabric, and pixi
phaser appears to sit on top of pixi (but not any more i guess) and to be a full-fledged engine
i think that is *not* what i want, and that i want pixi or fabric instead
i just want a renderer, i don't want someone else's game engine

https://github.com/alexkehayias/chocolatier (seen above) uses pixi, read through its source if i go with pixi

http://sam-koblenski.blogspot.com/2015/08/a-barely-adequate-guide-to-javascript.html some guy who goes with pixi

"Anyway, I tried a few different options when I was building the tool, Fabric.js, Famo.us,
but nothing had close to the performance of PIXI."
hrm
pixi does have more stars/etc
i guess i'll prob go with it

https://groups.google.com/forum/#!topic/flashcodersny/rU0-3zD7QIo this guy says pixi over fabric

stumbled over http://squirrel.pl/blog/2013/03/28/two-ways-to-access-properties-in-clojurescript/ yet again
**** use only aset/aget when interacting with javascript libraries

ok so i'll go with pixi for now and if it feels too heavyweight i'll switch to fabric

http://www.mase.io/code/clojure/2015/02/07/pixi-cljs/
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixicljs/core.cljs
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixi/core.cljs

TODO next task is going to be to spend some time with pixi, make a pixi.cljs that wraps it

TODO i think the rendering system is going to have to subscribe to movement events
like, successful-move events, ones emitted by the collision system
whenever a successful move happens, the relevant entity's pixi object needs to be mutated to reflect the
new position

collisions:
https://gamedev.stackexchange.com/questions/33731/collision-detection-and-response-in-an-entity-system

*****
ok so the goal for tomorrow is to work on the `pixi` branch
learn a lot about pixi by reading and playing around with it
begin work on a wrapper library for it
and begin work on a pubsub event system so that the render system can subscribe to move events

ignore the concept of collisions for now, forget they exist

=========

2/25/16

here are my goals for today

design and build a simple event system
codify schemas for systems
  they can have an :every-tick field whose value is a map like
    {:reads #{:render-info :position}
     :fn (fn [entity] entity) ; TODO should this take a single entity or a list of entities? prob the latter for perf?
     }
  they can also have an :event-handlers field whose value is a list of maps like
    {:handles an-event-type
    :fn (fn [event] something) ; TODO should this also take a system? what values should it return? does it just perform side effects?
    }

...and ideally i'd like to start wiring the rendering system up so that it listens to events
that are emitted by the movement system (because pixi.js relies on mutability, so we'll
like have all of these objects in flight that represent each entity, and so when each
entity moves we have to mutate its corresponding object's x and y, etc),
but i doubt that i'll get to that today.

let's just mainly focus on designing an event system (likely using core.async) and codifying
the schema for System.

pixi links to look at later, haven't processed these yet:
http://sam-koblenski.blogspot.com/2015/08/a-barely-adequate-guide-to-javascript.html
http://www.mase.io/code/clojure/2015/02/07/pixi-cljs/
https://github.com/alexkehayias/chocolatier/blob/5bc509f32f12411848c995f1e11ef917e87d6cbb/src/cljs/chocolatier/engine/components/renderable.cljs
https://github.com/alexkehayias/chocolatier/search?utf8=%E2%9C%93&q=pixi
https://github.com/alexkehayias/chocolatier/blob/dev/src/cljs/chocolatier/engine/systems/render.cljs
https://github.com/alexkehayias/chocolatier
https://github.com/pixijs/pixi.js
https://pixijs.github.io/docs/
http://www.goodboydigital.com/pixi-js-tutorial-getting-started/
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixicljs/core.cljs
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixi/core.cljs

ok
so what should our event system look like?

core.async pubsub info
https://github.com/clojure/core.async/wiki/Pub-Sub
...hrm

https://yobriefca.se/blog/2014/06/04/publish-and-subscribe-with-core-dot-asyncs-pub-and-sub/

"While the pub/sub mechanism provided by core.async is higher level than working directly
with chans and mults to achieve the same thing (in fact that is how the pub/sub operations
are implemented internally) it should still be considered a set of lower level primitives
compared to say a specific event bus notification with topic namespacing, wildcard broadcasting
and other such specialised features."

"I found the idea a bit easier to understand when I thought of the publication as a
realised topic or set of topics."

re: docstrings, here's the "would this work with multiple arities?" post i've been remembering lately
https://www.reddit.com/r/Clojure/comments/3nko85/having_trouble_with_pubsub_with_coreasync_channels/

https://clojure.github.io/core.async/#clojure.core.async/pub

https://github.com/search?utf8=%E2%9C%93&q=core.async+pub+extension%3Aclj+extension%3Acljs&type=Code&ref=advsearch&l=&l=

ok it looks like i'm *kinda* on my own here re: prior art
here goes

ok i split things up a bit and made an events ns
next up: have move-system send a dummy event to render-system

ok, that worked pretty well. now let's get move-system only send the event when an entity has actually moved
