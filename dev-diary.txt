2/20/16

http://www.mattgreer.org/articles/a-game-made-with-reagent/ talks about using css animations; TODO

https://rafalcieslak.svbtle.com/9-tips-for-clojurescript-beginners has a few good links
mentions checkout dependencies

======

2/21/16

https://developer.mozilla.org/en-US/docs/Games/Techniques/Efficient_animation_for_web_games
****** this article appears to be super good
has tips on how to avoid drawing things multiple times per frame (which would be a waste)
mentions https://github.com/BernieSumption/animator.js which is super old
cf http://blog.berniesumption.com/software/animator/
" For a modern library that exposes CSS animations through a similar API, I recommend jQuery.Transit."
so maybe the mdn article above is real out of date?

https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame

anyway tbh i think i should probably be using canvas instead of svg for a bullet-hell shooter/rpg
i think reagent+svg/divs/whatever makes tons of sense for turn-based games like cljstone
but for a boi clone, it really seems like square peg round hole

css/svg/etc animation links for later if i end up wanting them:
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions

anyway overall it looks like css transformations/animations are useful for situations where, like,
you've got a particular UI that you want to animate - but i don't think they're at all relevant for
a game in a web browser, it just doesn't make any sense

re: reagent and canvas (already expected these two wouldn't work together):
https://www.reddit.com/r/Clojure/comments/3cq5hg/can_reagent_components_work_with_html_canvas/
"No, and I've tried: https://github.com/gzmask/embodier-gcode-webgl"


canvas resources:
https://github.com/rm-hull/monet [seems abandoned; TODO read anyway, might have good ideas]

core.async and keyboard events: https://github.com/bdrillard/async-key-events

had trouble getting access to goog.events.KeyCodes, was given
http://clojurescriptmadeeasy.com/blog/when-do-i-use-require-vs-import.html in slack

TODO what the hell is an entity component system
https://github.com/markmandel/brute
https://github.com/muhuk/clecs
https://github.com/weavejester/ittyon

TODO what is http://wercker.com/

http://hueypetersen.com/posts/2016/02/13/om-next-from-a-relay-graphql-perspective/
incomprehensible om.next/relay/redux/graphql post

https://eklitzke.org/effectively-using-bash-profile evan notes on .bash_profile vs .bashrc

http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/ core.async implementation
http://hueypetersen.com/posts/2013/07/10/code-read-of-core-async-timeouts/ also good post on timeout!

http://hueypetersen.com/posts/2013/06/17/angular_is_slow/ - unrelated, but good quote:
"Your model is not your view model. It can be for simple cases, but as soon as you start feeling
friction you want to let the view model evolve instead of changing your domain models to suit the view."
****** gold stuff

ok so what is https://github.com/pedestal/pedestal
i remember this being announced at clojure/west a while back but don't know anything about it
lol "Our primary focus for the near future is Pedestal documentation, sample applications and
improving general ease of use."
so i think i can be forgiven for closing this tab and checking back later
https://github.com/pedestal/pedestal/tree/master/guides/documentation for the record

edmund says to use https://github.com/edmund-huber/sssgen for my blog
i'm sure he's not biased

https://en.wikipedia.org/wiki/Entity_component_system - see "game example" section
really good info
one of the main touted advantages is "composability instead of inheritance" - so is ECS still relevant in cljs?
the description of components sounds a lot like clj/s protocols

https://stackoverflow.com/questions/1901251/component-based-game-engine-design
the guy in that answer says use FRP instead of ECS

https://web.archive.org/web/20140719094839/http://www.altdev.co/2011/10/08/a-handful-of-components/
********* good shit
"The health component is probably the component that I re-use the most. Not just a health value that goes up
and down it also keeps track of invulnerability, regeneration and poison. It also looks after the entities
damage modifies with the following types currently supported Fire, Ice, Melee, Projectile, Magic and Crushing"

notes before i forget

what does game state end up looking like? do we end up adopting some ecs concepts and going with like

state: {:entities [Entity]}
Entity: {:id s/Int
         :components [Component]}

having an id helps for generating ^keys
what do rooms look like? are they some sort of, like, container components?
or do we have an :entities list and a :rooms list? the player's only in one room at a time if that's relevant

=======

2/22/16

https://www.youtube.com/watch?v=9sc8Pyc51uU
******* great talk on graphql / relay

https://github.com/devknoll/graphql-resources graphql links

https://www.youtube.com/watch?v=UoZyyo2Bwr8 talk on hoplon/javelin
difficult to tell how to reason about it with regard to reagent
he trashtalks the virtual dom for a while but i don't think all his criticisms apply
not a super big fan of the tone of this talk in general, the tech looks useful but not much different from reagent

reading https://github.com/evancz/elm-architecture-tutorial/

TODO for boi what will movement look like? does a player have a :bounding-box {x y width height} and a
:movement-state [:down :right]? that could work.

at some point i want to read the react dom-diffing code but i have 600 other tabs to process first

ok time for http://elm-lang.org/guide/reactivity
"Note: It is usually best to use signals as little as possible. When it comes to writing nice modular code,
you should primarily use normal functions and values. If you find yourself stuck with a signal of signals,
ask yourself “how can I model this explicitly with functions and values?”"

https://www.reddit.com/r/elm/comments/3s6lhb/learning_elm_vs_haskell_as_an_intro_to_functional/ elm vs haskell

reading http://elm-lang.org/blog/blazing-fast-html
"Virtual DOM sounds pretty slow, right? Create a whole new scene on every frame? This technique is actually
widely used in the game industry and performs shockingly well for DOM updates when you use two relatively
simple techniques: diffing and laziness." *******

"game industry" phrase links to https://en.wikipedia.org/wiki/Scene_graph

https://pchiusano.github.io/2014-07-02/css-is-unnecessary.html advocates using a lang like elm instead of css
"A little reflection on the history of software reveals abstraction as the primary means by which humans
make increasingly complex software possible and comprehensible."

https://news.ycombinator.com/item?id=9797973 om rant thread


************
okokok here's what i want to build
bullet-hell, twin-stick, top-down, boi-style combat/gameplay (except tear height, fuck that)
boi-style items
diablo-style levels (randomly generated floors rather than rooms; hallways, forests, whatever)
simple RoR-style leveling (don't care about skill trees / talents, just want to avoid staying at base damage
  forever like you often do in BoI)

updated state sketch
state: {:entities [Entity]
        :mode (s/enum :menu :loading :normal :etc)}
Entity: {:id s/Int
         :type (s/enum :player :bullet :monster :wall :etc)
         :components [Component]}

************

elm architecture notes:
https://gist.github.com/evancz/2b2ba366cae1887fe621
talks about advantages of having a centralized home of application state - single source of truth


what does main game loop look like?
*****
`
update-movement-state ; let monsters decide to aggro, leash, change their direction, etc
update-movement-speeds ; update dx, dy
update-positions ; update x, y (should we combine this with update-movement-speeds? unclear)
update-status-effects ; poison, invincibility, etc
calculate-collisions
update-health (? or does calculate-collisions do this? what does calculate-collisions do? add to a queue of
  unresolved collisions? something else?)
perform-attacks (player and monsters can have an :attacking state, with an :attacks-per-second or something)
`
******
what else?
can these things be done in parallel? how?
i guess you could have each use pmap instead of map, that could work pretty well actually

what does poisoning look like? a PoisonComponent and a poison-system?
maybe StatusEffects and an apply-status-effects system
i kinda like that a lot actually

bullets can't collide with other bullets
so there's an Owned component maybe

interesting notes on virtual dom / diffing: https://gist.github.com/Raynos/8414846
http://calendar.perfplanet.com/2013/diff/
good notes on setState effects, dirtiness setting, etc

http://t-machine.org/index.php/2012/03/16/entity-systems-what-makes-good-components-good-entities/
lots of example entities, components, systems

"Ideally, you add a new component when you have a new “dimension” to the game objects. For instance,
if you’re adding a physics System, you may not need to add any new Components – it might be that all
you need is Location (containing x,y,x position and dx,dy,dz velocity) and RenderState (containing
screen-pixels x,y) – and that you already have those components."

***** note re xyz position, dxdydz velocity ******

note warnings re: "Many systems per component" being a warning sign
the two versions of badness listed:

You have – say – 8 variables in the struct where you should instead have two structs (components),
one with 5 variables, the other with 3.
You have – say – 4 variables in the struct, but different systems are using those variables to mean
different things. It works OK for now, but it’s very fragile – as soon as the different meanings
diverge even a little, your code is going to start breaking

goood shit in this article man

in the comments:
"In regard to components a good idea at times is to stuff as much data into a single component that
covers the complete purpose. This cuts down referencing multiple components over and over and there
is definitely a speed up in a tight loop. A good example of this is physics where in my efforts I
provide a default “KinematicsParams” component that has velocity, position, rotation, angular velocity,
angular rotation, etc. etc. all stuffed into one data component. The reason being is that instead of
referencing a single component for each parameter it’s much easier / quicker to reference one."

"Q: What are the thoughts about having components that dont have any data, but instead exists to label
a entity in a way. A: I’m all for it."

http://t-machine.org/wp-content/uploads/Aliqua-progress-2015-BUUG-v3.pdf describes entity systems

via http://entity-systems.wikidot.com/ -
Entity - A container into which components can be added,
  ****usually hierarchical (any Entity can have sub-Entities).****

"Whereas in an inheritance-based design, an enemy may have a complex inheritance chain such as
Damageable <- Actor <- GroundBasedActor <- Enemy <- ZombieEnemy, in a C/ES-based design you might
have a Health component, a GroundBasedMovement component and a ZombieAi component added to
an entity named ZombieEnemy."

"Rendering and updating may take place either by traversing the entire entity tree (slow), by
having entities register themselves to the respective services (service locator hell) or in a
hybrid approach where the renderer/clock system remember which components they found in the tree
while entities merely provide a change notification if components are added to them or removed
from them, allowing the renderer/clock system to re-check that part of the tree (complex).
This aspect of the design is however not part of the C/ES pattern."

http://t-machine.org/index.php/2007/11/11/entity-systems-are-the-future-of-mmog-development-part-2/
definition of entities/components
"For every discernible “thing” in your game-world, you have one Entity. Entities have no data and no methods."

all this stuff is very clojure-y - clear separation + composition of data and behavior
"Typical Systems in a game would be: Rendering System, Animation System, Input System, etc.
 The Rendering system wakes up every 16 milliseconds, renders every Entity that has the Renderable
 Component, and then goes back to sleep."

"But the vast majority of game development is orders of magnitude more complex than Chess.
If you try – for instance – to write a computer game of Chess, that has AI … you certainly
don’t have “a movement and position component”.
Instead, you have: movement, position, potential positions this turn, potential positions on
future turns, threat radius, threatened squares, tactical options, strategic options, available
“plays” (famous chess strategies), enemy-histories-per-piece (what does your opponent tend
to do with pawns?) … etc."

http://t-machine.org/index.php/2007/12/22/entity-systems-are-the-future-of-mmog-development-part-3/
"So, don’t be tempted into hierarchical encoding, and definitely don’t do ANY encoding in the entity names"
“a System essentially provides the method-implementation for Components”.

components - data
systems - behavior
entities - id'd collections of data

"Mathematically-speaking, an Entity is a database Key, just as you’d see in any RDBMS.
Likewise, from a purely abstracted point of view, the “set of component-instances that comprise
Entity #7742” is, literally, a database Query.
THIS is why I said at the start that, ideally, you do NOT want to store your component-instances
as a list inside a struct/class representation of each Entity. Fundamentally, that set is NOT
defined as a list (a list is a static thing, it’s members don’t change without you changing them),
it’s defined as a query (whose members are always changing, whether you want them to or not),
and using one where really you wanted the other tends to cause problems in the long term."

hm - does all that still apply in clojure-land?
yeah prob not he says this is mainly for giant server-side games, which makes sense but
won't be super relevant for my tiny little client-side game

http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/
good article, not much different from the stuff above in t-machine
does have stories about introducing this design architecture into a preexisting system, neat

"Ideally, components should not know about each other. However, in a practical world, there
are always going to be dependencies between specific components. Performance issues also
dictate that components should be able to quickly access other components. Initially we had
all component references going through the component manager, however when this started using
up over 5% of our CPU time, we allowed the components to store pointers to one another, and
call member functions in other components directly."
hrm

http://scottbilas.com/files/2002/gdc_san_jose/game_objects_slides.pdf
"– Examples are trees, bushes, monsters, levers, waypoint markers, doors, heroes, inventory items
 – Many are “pure logic”, never see them (triggers, elevator movers, camera sequences)"

======

2/23/16

https://news.ycombinator.com/item?id=5116615 rant on ECS / clojure performance for games
fuck this guy tho

anyway i had a lot of ideas re: game this morning, jotting them down

current favorite name: voke (as in invoke, evoke, voco)

things i like about teleglitch:
punishing difficulty
setting/aesthetic (irrelevant, i'm not doing much art design here)
general terror about what's around the next corner
not so much into the crafting system, but was a fan of the health / armor system

bullets should be rectangular and thinnish rather than squares

if we end up making levels with hallways, i'm worried about the player cheesing the game by just
  funnelling all enemies through a hallway and shooting at them
i guess just don't have hallways?
what about doorways though?
i guess just have all doorways be way bigger than the player's/monsters' hitboxes, so monsters can always
  chase through really quickly

http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/
super good article
sort of unclear how to apply it to cljs tho

TODO - are deftypes/etc more performant than maps in cljs?

*****************
http://t-machine.org/index.php/2013/05/30/designing-bomberman-with-an-entity-system-which-components/
******* good shit
****** fuckin gold
"…if data should be in two components, but you can’t decide which: create a third component for it"
ok let's move all this stuff over to a new repo so i can start taking detailed game notes

ok per that post

behaviors:
move a player/monster/bullet in the direction is velocity indicates
player/monster runs into a wall, can't go farther in that direction
player/monster fires a bullet up/down/left/right
move a bullet along its vector
bullet collides with a player/monster, disappears, decrements health
monster/player collide, decrement player health
kill a player/monster
monster decides to aggro or leash
player/monster decides to change direction
player/monster decides to want to attack in a particular direction
player uses an active item
player picks up an item
camera moves to follow the player

data:
player/monster/bullet/wall collision-box
player/monster/bullet dx/dy velocity
player/monster/bullet top speed / acceleration
player intended move direction (8 options)
player intended fire direction (8 options)
monster intended move direction (360 degrees)
monster intended fire direction (360 degrees)
player/monster health
player armor
player xp
player/monster level
player inventory
player/monster bullet effects
bullets in flight
bullet owners
player/monster attack state [range, frequency, time since last shot]
item name and effect
camera
background


TODO how to take keyboard wasd/arrow input?

TODO look into public domain sprites for players/monsters/bullets/whatever

http://t-machine.org/index.php/2013/05/30/designing-bomberman-with-an-entity-system-which-components/comment-page-2/#comment-1274479
really great question
never gets an answer!

http://t-machine.org/index.php/2013/05/30/designing-bomberman-with-an-entity-system-which-components/comment-page-2/#comment-1274784
**********

http://t-machine.org/index.php/2012/04/19/concepts-of-object-identity-in-game-programming/
******* has notes on how systems can communicate with one another
eg kill enemy, enemy drops loot

*********
http://shaun.boyblack.co.za/blog/2012/08/04/games-and-entity-systems/ other guy's list of components/etc
******** GREAT post

http://www.richardlord.net/blog/what-is-an-entity-framework
ECS vs game loop
not much new info after i've read all the stuff linked above, but overall a great standalone post
"The collision system, which tests whether the player is colliding with other objects and
resolves those collisions."

"The systems are decoupled form each other. Each system knows only about itself and the data
it operates on. It knows and cares nothing at all about the other systems and how they may
have affected by or used the data before or after this system gets to work with it."
hm, discourages systems from communicating

but later...
"In most games, ***some*** of the systems are entirely independent of each other, including being
independent of the order in which they are applied. This makes it easy to run these systems in parallel."

anyway i mean i've been reading a bunch of this stuff and it's all cool and helpful but i'm not sure
how much of it applies in clojureland. in clojure you'd just be passing maps around to different functions
anyway, you'd have a clear separation of code and data, which is what ECS is all about.
so at the end of the day the main distinction is between, like, do i have game objects like this?

{:id 123
 :type :player
 :position a-position
 :velocity a-velocity
 :intended-movement-state an-intended-movement-state
 :firing-state a-firing-state
 etc
}

or do i have objects like this:

{:id 123
 :components [player-controlled, a-position, a-velocity, an-indended-firing-state]
}

ECS is all about the second option i think, although it's sort of six-one-half-dozen-other, maybe doens't matter.
might as well give it a shot

TODO - what does player-controlled look like? does it contain both intended movement direction
  and intended firing direction? what about active item usage, how does that work?

http://gameprogrammingpatterns.com/component.html
****** has a section on how components communicate with one another!!!!!!

"sending messages" - sounds familiar

so i guess the idea proposed here is that entities have a "send" function, and components have a
"receive" function
i mean that's all pretty OO
in clj, it'd probably look more like

(messaging/send an-entity-id a-message)

that seems reasonable

but what does it end up actually doing? like let's say we do
(messaging/send 1234 {:type :player-direction-input
                      :value :UP})

where does the code live that handles that message?
i guess you let components subscribe to specific types of messages and have some sort of "bus"
(what does that term even mean?) that coordinates all this; i know core.async has facilities along these lines

hm hm hm

"Some domains are distinct but still closely related. Think animation and rendering, user input
and AI, or physics and collision. If you have separate components for each half of those pairs,
you may find it easiest to just let them know directly about their other half.

Messaging is useful for “less important” communication. Its fire-and-forget nature is a good
fit for things like having an audio component play a sound when a physics component sends a
message that the object has collided with something."

hm i'm not sure about the messaging/send stuff from above

ok so what about if like for instance the physics component just adds a PendingAudio component
and the audio system looks for PendingAudio components on each tick, plays them, and removes them

and so the velocity component directly reads from the player-input component

and the player-input component is... directly sent messages via the UI?
hm how does it get its stuff

i guess the game's business logic is a module that has a clearly defined API
and only has a few specific public functions

(accept-player-input a-message)
(let-time-pass time-delta)

and so accept-player-input is a function that under the hood modifies components, and even then
just like the direction the player is intending to move and fire

and also i guess like (pause-game) etc

so what does the game's state currently look like?

{:entities [Entity]
 :mode Mode ; for pausing, menus, game over, whatever
 :active-level an-entity-id ;?
 ; maybe a channel but probably not, it can be local to the root reagent component
}

https://gamedev.stackexchange.com/questions/31473/what-is-the-role-of-systems-in-a-component-based-entity-architecture/31491#31491
not sure about the metaphor, but the main message is that systems can read from multiple components at once
*** for perf, it suggests having each entity have a bitfield indicating which components it has; that could work

https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/levels/first.cljs
**** level built in clj with an ECS
"In ChromaShift's case the core structure and caches for the engine are actually written in
JavaScript for performance reasons, while all of the game CES is written in ClojureScript."

http://www.clojure-games.org/component-entity-system

https://github.com/muhuk/clecs-examples/blob/master/clecs-example-roguelike/src/clecs_example_roguelike/entities.clj
example entities/components

i like https://github.com/muhuk/clecs/blob/master/src/clecs/system.clj -
rather than having systems just be functions, he has them be maps
so in addition to a function that takes a world and returns a new one, he has other metadata too like
:name :rendering
:reads #{:Inventory :Renderable}
:writes #{:Inventory :Location}
interesting! overkill or helpful/necessary?

http://alexkehayias.tumblr.com/post/78711349238/entity-component-model-in-clojurescript
ecs with protocols/records

https://github.com/alexkehayias/chocolatier/ yet another system that talks a lot about:
"Think about it less as a bunch of objects with their own state and methods and more like
a database where you query for functionality, state, based on a certain aspect or entity."

i've seen this talk of databases+queries like 10 times now in reference to ECS, not sure
what i think about it

chocolatier has notes about cross-component communication
"A global pub-sub event queue is available for any component enabling cross component communication
without coupling the state of any of the components. For example, suppose the render component
needs to update the screen position of the player sprite. The render component needs information
from the input component, but we don't want to couple the state of either components together.
Instead of directly accessing the input component's state from the render component we subscribe
to messages about player movement and update based on that. We can broadcast that information without
any knowledge of who is listening to it and no one can change the component state from another component."

not sure i 100% agree with the components he's come up with, but anyway here's another bit of precedent
for messages / pubsub

"Any component can subscribe to events by creating a component with a :subscriptions key in the options
hashmap where each subscription is a vector of selectors:
 (mk-component state :player1 [component-f {:subscriptions [[:e1] [:e2]]}])
The subscribed component will receive the event in a hashmap in the :inbox key passed in as the
third argument to the component function. Messages that are sent are available immediately to
the subscriber which allows for events to be sent and received within the same frame and are
therefore order dependent."

interesting

"ClojureScript presents challenges for optimization including garbage collection, persistent
data structures, and functional paradigms that js engines may have difficulty optimizing."
eep

"Where appropriate, transient state should be used when operating on large collections and
hashmaps for better performance. See chocolatier.macros in the clj source directory for
helpers with transient state. "

re: performance
https://stackoverflow.com/questions/21721028/how-to-improve-clojurescript-performance
"Now, if performance is really critical to what you're doing and persistence provides
no benefit, you can just use arrays and objects from ClojureScript:"
"By using records and native field access, you can cut the runtime for your
original ClojureScript solution in half"

http://numergent.com/2015-12/ClojureScript-performance-revisited.html
******
"As we can see it’s doing this with a regular vector, which we can easily turn into a
transient one and persist it once we’re done."
bought him 1 fps, 12->13
lists other, more impactful techniques
mentions `keep` as a one-pass map+filter

http://davedellacosta.com/cljs-protocols notes on protocols

http://www.bestinclass.dk/blog/brians-brain-optimized-clojurescript-html5

https://swannodette.github.io/2013/06/10/porting-notchs-minecraft-demo-to-clojurescript/ nolen on perf

okok that's enough reading for now
tomorrow i should be able to start actually coding something
and constantly be terrified that i'm violating all the principles i've read about or some shit

TODO look into a good canvas js library that i can use via cljsjs

https://web.archive.org/web/20140509212857/http://resatori.com/clojure-entity-component-system

unrelated: http://yogthos.net/posts/2016-02-22-LuminusEmbracingHugSQL.html - yesql no longer developed?

http://elbenshira.com/blog/the-end-of-dynamic-languages/
http://yogthos.net/posts/2015-11-28-TheSkyIsNotFalling.html
dunno about this argument

http://retroaktive.me/blog/keechma-design-decisions/

https://github.com/tonsky/datascript - relevant for storing entities?

======

2/24/16

ibdknox uses a js stats library in https://github.com/ibdknox/ChromaShift/blob/master/js/lib/stats.js
see https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/lib/dev.cljs

he uses ! and ? as aliases for aset and aget, not sure if i like it but here we go
https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/lib/core.cljs

physics in https://github.com/ibdknox/ChromaShift/blob/master/cljs/game/lib/physics.cljs
note the Box2D library he seems to be using

ok you know what i think my entities are just going to look like

{:id 1234
 :type :player
 :position a-position-component
 :bounding-box a-bounding-box-component
 :etc etc}

rather than

{:id 1234
 :components [a-position-component a-bounding-box-component etc}

i think that the second style makes a lot of sense if you're outside of clojure and are used to OOP and
trying to force yourself out of it, but i don't think it's required here. i also think that the second
style is particularly good about discouraging components from communicating with one another, and also
that it probably makes a lot of sense in eg an MMO where you have a jillion entities and a jillion components
and you want to store their relationships in a RDBMS. but that's not us here. so i think i'll just use dicts.

http://box2d-js.sourceforge.net/ here's that box2d library
more relevant if you want gravity, etc; let's skip it imo

still having a lot of trouble figuring out what position components should look like
are they just an :x and a :y, or do they also have a :width and a :height?
i know that ideally :width and :height would be for bounding boxes, but like what *doesn't* have a shape like that?
i think in this game i'm going to have everything be rectangular, so nothing
so you have a :position with an :x and a :y and a :width and a :height
and you can also optionally have a CollisionBox with a :width and a :height
things that don't have collision boxes: scenery, basically nothing else
end of level has a collision box so you know when the player's walked into it
items/pickups have collision boxes for same reason
so i guess collision boxes have some sort of like :obstruction true/false field

seriously do look into that stats.js thing, it looks legit
https://github.com/mrdoob/stats.js/
note the bookmarklet!!!!

ok cool this bookmarklet works:
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();stats.domElement.style.cssText='position:fixed;left:0;top:0;z-index:10000';document.body.appendChild(stats.domElement);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)}); document.getElementById("ms").style.display="block"; document.getElementById("mb").style.display="block";};script.src='http://rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

lots of notes from my walk, going to try to get them all down before i forget them
you have a few systems that run every tick
movesystem, firesystem
they read from intended-move-direction and intended-fire-direction
which for human-controlled entities is written to directly by the keyboard (via an interface)
and for AI entities is recalculated every tick [so there's another one that's run every tick]

but most of your systems just listen to events
collisionsystem listens for intended-move messages
damage system listens for contact messages
xp system listens for kill messages
etc

and so you have this like event graph / dependency graph between the systems
and so you have a few that are running every tick, and most of them always running and just listening
for events constantly
and the rendering system runs every tick too


unrelated
status effects:
poison
freeze
knockback
slow
stun (same as freeze?)

okok so we're almost ready to get started but first i want to make sure my ideas about events + ECS
aren't completely insane, so i have a bunch of google tabs open about that

https://github.com/MovingBlocks/Terasology/wiki/Entity-System-Architecture talks about events
cool-looking project btw, voxel world thingy

"ComponentSystems, or Systems for short, provide behavior to entities. They do this in two ways
Processing entities with a desired set of components in response to engine method calls like
initialise(), update(float delta) and render()
Responding to entity events sent to entities with a desired set of components"

yeah, that sounds kinda like what i have in mind, cool

"The health system would respond to an entity with a Health component receiving a Damage event,
in order to reduce an entity's health - and if the health reaches 0, send a Death event to the entity"

in this design of theirs, *entities* receive events rather than systems receiving events. not sure if
i agree with this, prob won't do that

https://github.com/MovingBlocks/Terasology/wiki/Entity-System-Architecture#events-and-event-handlers good shit

" Systems can then provide event handlers to pick up specific events that have been sent entities
with a desired set of components. Expanding on the Damage event, you may have a System that handles
damage events that occur on entities with health components, in order to reduce health. Or a System
that handles damage events for entities with a location and physics component, to knock the entity
away from the damage causer."

i'm still not convinced that sending messages to entities is correct

"Events also support cancellation - this allows a system to stop an event before it
eaches systems with a lower priority - for instance if you add an invincibility component
to make an entity temporarily immune to damage, you can add a system that will intercept
the Damage event and cancel it before it can reach the health system."

hrm hrm hrm

https://www.gamedev.net/topic/643311-events-and-entity-component-systems/
good first post, bad responses

https://gamedev.stackexchange.com/questions/47476/tips-for-component-based-entity-system-message-handling
"Although I haven't implemented a way to handle events (other than entity-related events),
I left that up to the user" lol

https://gamedev.stackexchange.com/questions/83767/communication-pattern-in-entity-component-system
"There is no right answer to your question and a lot of it comes from personal taste and out of need."
fair nuff

http://unity-coding.slashgames.org/component-based-entity-systems-event-driven-systems-to-implement-the-logic/
"As a system is very self-contained, events are the way to communicate with other systems and the world
outside a system in general."
yes yes fine ok

http://forums.xkcd.com/viewtopic.php?f=11&t=81459
"the major strength of component systems: you minimise communication overheads and you can easily "batch" updates."

http://tarheadstudio.com/entity-component-system/
"Have you considered an event system of some sort on top of this?"
"Yes. The way we have solved it is rudimentary though: systems send messages, which is an object with
some data, to a game manager, who propagate the message to every other system."

ok so at this point i'm convinced that my design is good

******
so we're going to go with the style of entities/components that i talked about at the start of today's notes
and there will be a bunch of systems that exist
and some systems will run on every tick
and other systems will just listen for events
and there are some examples of those two kinds of systems in today's notes above
rad

https://github.com/tonsky/41-socks/blob/gh-pages/src/forty_one_socks.cljs

http://www.compoundtheory.com/ prettiest blog ever
http://www.compoundtheory.com/brute-entity-component-system-library-0-2-0-the-sequel/
started side-effecty, went functional
ok so anywyay i'm not going to use brute

http://www.compoundtheory.com/writing-a-game-feels-like-im-going-around-in-circles/
TODO free sprites at http://www.widgetworx.com/spritelib/
apparently http://www.physicsclassroom.com/ is good for physics

http://www.compoundtheory.com/mini-game-dev-diary-1/ cool stuff

http://www.pixijs.com/ claims to be super fast

ok so i need to pick a rendering library
first contenders i found are phaser, fabric, and pixi
phaser appears to sit on top of pixi (but not any more i guess) and to be a full-fledged engine
i think that is *not* what i want, and that i want pixi or fabric instead
i just want a renderer, i don't want someone else's game engine

https://github.com/alexkehayias/chocolatier (seen above) uses pixi, read through its source if i go with pixi

http://sam-koblenski.blogspot.com/2015/08/a-barely-adequate-guide-to-javascript.html some guy who goes with pixi

"Anyway, I tried a few different options when I was building the tool, Fabric.js, Famo.us,
but nothing had close to the performance of PIXI."
hrm
pixi does have more stars/etc
i guess i'll prob go with it

https://groups.google.com/forum/#!topic/flashcodersny/rU0-3zD7QIo this guy says pixi over fabric

stumbled over http://squirrel.pl/blog/2013/03/28/two-ways-to-access-properties-in-clojurescript/ yet again
**** use only aset/aget when interacting with javascript libraries

ok so i'll go with pixi for now and if it feels too heavyweight i'll switch to fabric

http://www.mase.io/code/clojure/2015/02/07/pixi-cljs/
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixicljs/core.cljs
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixi/core.cljs

TODO next task is going to be to spend some time with pixi, make a pixi.cljs that wraps it

TODO i think the rendering system is going to have to subscribe to movement events
like, successful-move events, ones emitted by the collision system
whenever a successful move happens, the relevant entity's pixi object needs to be mutated to reflect the
new position

collisions:
https://gamedev.stackexchange.com/questions/33731/collision-detection-and-response-in-an-entity-system

*****
ok so the goal for tomorrow is to work on the `pixi` branch
learn a lot about pixi by reading and playing around with it
begin work on a wrapper library for it
and begin work on a pubsub event system so that the render system can subscribe to move events

ignore the concept of collisions for now, forget they exist

=========

2/25/16

here are my goals for today

design and build a simple event system
codify schemas for systems
  they can have an :every-tick field whose value is a map like
    {:reads #{:render-info :position}
     :fn (fn [entity] entity) ; TODO should this take a single entity or a list of entities? prob the latter for perf?
     }
  they can also have an :event-handlers field whose value is a list of maps like
    {:handles an-event-type
    :fn (fn [event] something) ; TODO should this also take a system? what values should it return? does it just perform side effects?
    }

...and ideally i'd like to start wiring the rendering system up so that it listens to events
that are emitted by the movement system (because pixi.js relies on mutability, so we'll
like have all of these objects in flight that represent each entity, and so when each
entity moves we have to mutate its corresponding object's x and y, etc),
but i doubt that i'll get to that today.

let's just mainly focus on designing an event system (likely using core.async) and codifying
the schema for System.

pixi links to look at later, haven't processed these yet:
http://sam-koblenski.blogspot.com/2015/08/a-barely-adequate-guide-to-javascript.html
http://www.mase.io/code/clojure/2015/02/07/pixi-cljs/
https://github.com/alexkehayias/chocolatier/blob/5bc509f32f12411848c995f1e11ef917e87d6cbb/src/cljs/chocolatier/engine/components/renderable.cljs
https://github.com/alexkehayias/chocolatier/search?utf8=%E2%9C%93&q=pixi
https://github.com/alexkehayias/chocolatier/blob/dev/src/cljs/chocolatier/engine/systems/render.cljs
https://github.com/alexkehayias/chocolatier
https://github.com/pixijs/pixi.js
https://pixijs.github.io/docs/
http://www.goodboydigital.com/pixi-js-tutorial-getting-started/
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixicljs/core.cljs
https://github.com/maseb/lab-pixi-cljs/blob/master/src/pixi/core.cljs

ok
so what should our event system look like?

core.async pubsub info
https://github.com/clojure/core.async/wiki/Pub-Sub
...hrm

https://yobriefca.se/blog/2014/06/04/publish-and-subscribe-with-core-dot-asyncs-pub-and-sub/

"While the pub/sub mechanism provided by core.async is higher level than working directly
with chans and mults to achieve the same thing (in fact that is how the pub/sub operations
are implemented internally) it should still be considered a set of lower level primitives
compared to say a specific event bus notification with topic namespacing, wildcard broadcasting
and other such specialised features."

"I found the idea a bit easier to understand when I thought of the publication as a
realised topic or set of topics."

re: docstrings, here's the "would this work with multiple arities?" post i've been remembering lately
https://www.reddit.com/r/Clojure/comments/3nko85/having_trouble_with_pubsub_with_coreasync_channels/

https://clojure.github.io/core.async/#clojure.core.async/pub

https://github.com/search?utf8=%E2%9C%93&q=core.async+pub+extension%3Aclj+extension%3Acljs&type=Code&ref=advsearch&l=&l=

ok it looks like i'm *kinda* on my own here re: prior art
here goes

ok i split things up a bit and made an events ns
next up: have move-system send a dummy event to render-system

ok, that worked pretty well. now let's get move-system only send the event when an entity has actually moved

ok wow i went into a fugue for a bit and all the code is all fucked up now but i think systems are now maps
and that their tick function gets called with a list of only the relevant entities
TODO that sure sounds worth writing tests for

anyway tomorrow i should look at all this code with fresh eyes and look for things that seem insane
and refactor them and simplify them
but right now the box is moving around like it's supposed to and i have no idea what i did and i'm going to
eat something soon, so i'm going to take a break

also TODO afterward (ONCE ALL THE CODE DOESN'T LOOK INSANE ANY MORE): actually automatically wire up event handlers

also eventually i should make the character tinier like in RoR, i like that style, too big atm

=======

2/26/16

ok so here's where i'm at
it is not super clear how systems should talk to each other
google has no obvious single best accepted solution

my favorites so far:
* ephemeral, "pending-foo" components - so when the collision system detects that two things have collided
  (and either kills the projectile or cancels the pending movement event), it adds a "pendingdamage" component
  to the relevant entities, and the damage system looks for those and handles them and removes them when they've
  been processed
  * pros:
    * easy to remain purely functional in this world ++
    * every system runs once per tick, they communicate with one another via ephemeral components that are
      processed / removed each tick, everything's just a function, everything's synchronous and relatively easy
      to reason about
  * cons:
    * extremely tight coupling. collision system has to know that damage system exists and emit a "pendingdamage"
      component. that seems super dumb. or it emits a "pendingcontact" component, but if several different systems
      read from those, only *one* of them can be responsible for removing them when they've been handled,
      and so all of a sudden like ordering of functions in the tick matters and everything is super tightly
      coupled together and life is awful

so probably not that one. the other alternative i have so far is

* event system - so when the collision system's sole responsibility is to _listen for_ entities that are
  attempting to move, and then either apply the movement or reject it and notify the rest of the world
  that a contact event happened, and the rest of the world can like render differently / play a noise / apply
  damage / whatever
  * pros:
    * loose coupling holy grail basically
  cons:
    * when, say, the damage component's :contact event handler gets run and it decides that entity 4 should
      have its :health decremented by 25 or whatever, it is not immediately clear *how* that change should take
      place. all the event handler has is an event - it doesn't (shouldn't!) have access to the game-state atom,
      because that'd be global mutable state.
    * everything is asynchronous now, and so i worry that this will open me up to more difficult-to-reason-about
      performance problems / general bugs

so my current plan is to go with the event-based system, and just deal with the fact that i'll have some
sort of global-ish mutable-ish state [i'll have it hidden behind an interface of functions, like
(update-entity! entity-id update-in [:foo] bar baz) or whatever].

and so the way that event handlers will update the game is by sending an event like

{:event-type :update-entity
 :entity-id 1234
 :fn (fn [entity] updated-entity)}

and there'll be a single go-block consumer whose job it is to handle these events (maybe just :update-entity,
but maybe other events like :pause-game or whatever too, not sure yet we'll get there later) and update the state
of the world to reflect decisions that have been made in systems' event handlers. and so event handlers
will take args [the-event publish-chan], and that's how they'll be able to emit messages like this.

i think this system will work. i'll need to do some thinking/designing in order to come up with a good
API for changing the state of the world, and will want to come up with a way of hiding the actual mutable
`state` atom from the rest of the program (likely via a closure of some sort), but i think i can make this work.
i don't think the ephemeral-component approach is a good one, i think this event one will work though.

cool so i did a tiny amount of refactoring and now i think i'm ready to dive into pixi
opened all those tabs from above back up again

http://www.goodboydigital.com/pixi-js-tutorial-getting-started/ "launch last month" april 2013 (?!)
"Stage represents the root of our display tree."
" A renderer draws a stage and all its contents to the screen"

ok i'm almost out of battery and need to take a break
but the next thing i need to work on is getting super familiar with pixi and like adding
something to the stage and moving it around and drawing it

i'll need to read through all these goddang tabs to get super familiar with how pixi works
and eventually i'll want to make a pretty api that sits on top of it

ok, so what's the specific problem i'm having with rendering engine reloadability?
i guess i mainly don't want my renderer and stage js objects to be blown away when the rendering ns is reloaded
what other state will we have?
likely a map from entity-id -> sprite (or some such object)
everything else can be blown away

so i guess we have two options
we put a :rendering-engine k/v pair on the GameState map
or we have a private rendering-engine atom that's kept inside the rendering system's ns

the latter seems like the less testable approach to me, which is often a smell
but i'm also not in love with having a :rendering-engine k/v pair on GameState, because that makes this
mutable data essentially global

yeah i think having a private rendering-engine atom in the rendering system's NS is fine
if we want to we can always with-redefs it in tests

ok, gotta learn more about pixi's API
does everything need to be a Sprite?
what's a Graphics?

http://sam-koblenski.blogspot.com/2015/08/a-barely-adequate-guide-to-javascript.html

objects appear to have a .clear() function

ok christ finally
******** https://github.com/kittykatattack/learningPixi appears to be the way to learn pixi
"I know for a fact that it's the best book, because I wrote it!" ugh
"If you aren't running a webserver, Pixi won't work" concerning
lots of bullshit about how you need to "install" pixi, urgh, false/misleading

apparently http://www.goodboydigital.com/pixi-js-v2-fastest-2d-webgl-renderer/ explains the "resolution"
option you can pass when creating a renderer

https://github.com/kittykatattack/learningPixi#pixi-sprites for when i eventually want to add sprites/images
how to render boxes, though?
do i need a Graphics for that?

https://github.com/bhauman/flappy-bird-demo/blob/master/src/flappy_bird_demo/core.cljs
is a good example for how to make your animationframe function take+handle timestamp delta

https://github.com/kittykatattack/learningPixi#positioning-sprites positioning

https://github.com/kittykatattack/learningPixi#velocity can set sprite velocity rather than x and y

*****
https://github.com/kittykatattack/learningPixi#pixis-graphic-primitives here we go fuckin finally

https://github.com/kittykatattack/learningPixi#the-hittestrectangle-function notes on collision detection

notes from a fellow cljs pixi dev in
https://github.com/alexkehayias/chocolatier/blob/dev/todo.org#optimizations-2014-11-29-sat
**** lots of perf notes/goals there ************
note the "This did not end up working" bit re: .- props

"Make the input system emit an event
Currently it updates it’s component state but that’s it. SHould send an event to avoid
other components querying it directly "

super interesting notes here

https://github.com/alexkehayias/chocolatier/blob/5bc509f32f12411848c995f1e11ef917e87d6cbb/src/cljs/chocolatier/engine/ecs.cljs#L133

"The component function can return 1 result or 2. If 1 result then the
    output is treated as the component state. If it is 2 then the second
    argument is events that should be emitted. If format-fn is specified
    then you can implement whatever handling of results you want."

hrm not in love with all that

a note from his event system:
;; Avoid sending messages based recieving a message to prevent
;; circular messages happening

********
https://github.com/alexkehayias/chocolatier/blob/5bc509f32f12411848c995f1e11ef917e87d6cbb/src/cljs/chocolatier/engine/pixi.cljs
his interface around pixi

https://github.com/alexkehayias/chocolatier/blob/dev/src/cljs/chocolatier/engine/systems/render.cljs
his render system

http://www.wagjo.com/benchmark-cljs/ cljs perf - 2+ years out of date though!

"Partial is very slow. Also do note that creating anonymous function costs something.
Try not to create anonymous functions inside performance sensitive loops, as they are recreated
in each iteration."
*** good to know, need to keep an eye on this if(when!) perf becomes an issue

"Assoc in map or record is slow. Much faster is to have a custom type and copy it on every assoc.
 Update in map or record is slow. Much faster is to have a custom type and copy it on every update."
hrm. hrm hrm hrm.

http://www.yeahbutisitflash.com/?p=5666 talks about viewports
iii think we can sort of ignore it for now. come back to it when we implement the camera system
(which will follow the player i guess, i haven't thought about this at all yet)

http://www.yeahbutisitflash.com/?p=6496 sort of talks about level generation
ok it talks about performance too
GPUs and stuff, sprite sheets

talks about object pooling, which i'd like to avoid since we're in cljs but it's good to keep in mind for perf
if it becomes necessary

interesting re: "borrow"/"return" terminology
that's actually an interesting idea/technique

https://en.wikipedia.org/wiki/Object_pool_pattern
"When it is necessary to work with a large number of objects that are particularly **expensive to instantiate**
and each object is only needed for a short period of time, the performance of an entire application may be
adversely affected. An object pool design pattern may be deemed desirable in cases such as these."
none of our stuff is that expensive to instantiate
"Some publications do not recommend using object pooling with certain languages, such as Java,
especially for objects that only use memory and hold no external resources."

http://www.yeahbutisitflash.com/?p=7046 talks about maps
these articles are actually really surprisingly well put together
gj, this person

ok, that's probably enough for now.
next up:
do a pass on voke.core, split out user input logic
figure out how to communicate to the game that the player has pressed or unpressed a movement key

after that.. dunno! read about collision detection algorithms, add walls?

======

2/27/16

so is input.cljs a *system*? or is it just a file?
what characterizes a system? it's either something that runs every tick, or something that listens to and
optionally publishes messages that affect the state of the game, or both.

the input system won't run every tick, but it *will* publish messages that affect the state of the game,
so let's go ahead and make it a system.

ah - but the events it *listens* to *aren't* game events!
so i don't think it's a System after all.

it's a ns that is given access to voke.system.core's `publish-chan`

ok cool input is moved out of voke.core and totally works afaict
and we have a system set up that supports :update-entity events

i had one interesting bug where my events were looking like :type :update-entity instead of
:event-type :update-entity, and so my events were being dropped on the ground and i couldn't figure out why.
was irritating to debug; i know to look for it now, but still.
i can't easily find a way to subscribe to *all* topics on a publication, which would aid debugging. asking in slack.

actually nvm, listening for `nil` as described in https://yobriefca.se/blog/2014/06/04/publish-and-subscribe-with-core-dot-asyncs-pub-and-sub/
would have helped debug this, so i'll try that next time.

ok, time to read about collision systems

https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics
"A rigid body naturally rotates around its center of mass, and the position of a rigid body is
considered to be the position of its center of mass."

boy there is a lot of physics in this article

********************
http://www.toptal.com/game/video-game-physics-part-ii-collision-detection-for-solid-objects
"In the context of rigid body simulations, a collision happens when the shapes of two rigid bodies are
intersecting, or when the distance between these shapes falls below a small tolerance."
"If we have n bodies in our simulation, the computational complexity of detecting collisions with
pairwise tests is O(n2), a number that makes computer scientists cringe."
"In order to optimize the collision detection process, we generally split it in two phases:
broad phase and narrow phase."

all this stuff here is about 3d simulations i think
for the broad phase he talks about "space partitioning"

"There are plenty of space partitioning algorithms and data structures that can be used for this,
such as uniform grids, quadtrees in 2D, octrees in 3D, and spatial hashing."

great summary on sort and sweep here, looks like a really interesting+simple heuristic/approach

mentions that box2d implements all this stuff, so maybe i'll end up using that library after all

"concave shapes are harder to work with" - why, though?

"In a convex shape, a line segment between any two points within the shape always falls completelyx
 inside the shape. However for a concave (or “non-convex”) shape, the same is not true for all possible
 line segments connecting points in the shape. If you can find at least one line segment that falls
 outside of the shape at all, then the shape is concave." oh that makes sense

convex hull, convex decomposition
support functions

i'm really impressed by this article

https://gamedev.stackexchange.com/questions/26501/how-does-a-collision-engine-work
" In discrete methods, objects will end up penetrating each other, and the physics
engine then works to push them apart"
talks about "sleeping" objects, and a "contact cache"

***************
http://games.greggman.com/game/programming_m_c__kids/ (from 1993 [!!!!])
"In M.C. Kids the Hamburglar has stolen Ronald’s magic bag and you, as Mick or Mack, must find
the magic bag before Hamburglar does something we’ll all regret."

"Every object can only collide with one other object per frame, so every object is assigned a
collision priority so that it will collide with the most important object. It is more important
to know that the kid hit a monster than to know that the kid hit a PickupBlock."

********
"All objects have a collision matrix, so that they can only collide with certain other objects.
The kid collides with everything. A PickupBlock only collides with the kid and monsters.
Some monsters collide with the kid, other monsters, and various project tiles. Certain other
monsters don’t collide with other monsters. Not having to check every possible collision saves tons of time."

"Collisions: Now for the fun part. NOT!" hee

"Many of the reasons for these contortions have to do with speed. Most video game systems must
run at 60 frames a second, and if you have to look up 4 or 5 tile positions per collision pixel
per frame you are going to run out of time. All this is something you should consider when
designing a platform game. It is much easier the create a platform game with no slopes, so if
you are short on time, then design your game so that it doesn’t need slopes."

http://games.greggman.com/game/tweening/ tweening/lerping

*****
http://www.hobbygamedev.com/adv/2d-platformer-advanced-collision-detection/
"Once again, as with the tile-based example, we’ll be relying on the age-old trick of waiting until
after overlap occurs in logic, then correcting for the overlap before it has a chance to render incorrectly.
That will be “collision”. (I.e. no predictive/extrapolation calculations!)"

i'm glad this guy says that's legit, because that was my exact plan

**********
"Mathematically and computationally, it’s simple to tell whether two rectangles are overlapping:
two axis-aligned rectangles don’t overlap if and only if the left of either is right of the other’s
right or the top of either is below of the other’s bottom."

well, that's for *axis-aligned* rectangles... which, maybe all of the things in voke will be?
will bullets really be ellipses or will they have rectangular bounding boxes?
probably the latter, right? no reason to do the former IMO
but i've considered like diamond-shaped bullets, and those won't be axis-aligned
so maybe this approach won't work for me. good to know about though, makes sense
although i guess the point re: axis-aligned rectangular bounding boxes is that you could *construct* one
around a diamond relatively easily (how ?), and then use *it* to test for collisions.

quad trees are good

"the simplest way to avoid tunneling – and the method used by most 2D platformers,
including Everyone’s Platformer – is to just enforce safe upper bounds on speed and design
with safe lower bounds on sizes"

makes sense

***** favorite explanation/diagram for bounding box collision
http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/

http://gamedevelopment.tutsplus.com/tutorials/quick-tip-use-quadtrees-to-detect-likely-collisions-in-2d-space--gamedev-374
more detail on quadtrees/implementation

https://katyscode.wordpress.com/2013/01/18/2d-platform-games-collision-detection-for-dummies/

the "mask approach" described here is very similar to what i'd had in mind when i was thinking about how i'd
implement collision detection from scratch

basically the main thread through all of these articles is that, yes, detecting everything one pair at a time
is n^2, and so you want to do less work than that. quadtrees and aabbs are a good way of doing a broad pass
at collision detection. see the sort-and-sweep algorithm described in an article above.

so anyway in this game i'll only be doing the broad stuff because i don't care about like actual super fine
grained detection of like whether or not a circle *really just barely* missed a rectangle

https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection

https://www.quora.com/How-can-I-self-study-Linear-Algebra tips on linear algebra
i.... don't understand this advice

http://betterexplained.com/articles/linear-algebra-guide/
ok sure let's spend a while working through this
eventually i'll look up js collision detection libraries
but i don't know anything about matrices/vectors and this seems like as good a time as any
to sit down and learn some about 'em

"In math terms, an operation F is linear if scaling inputs scales the output, and adding inputs adds the outputs"
"Our only hope is to multiply by a constant"
"However, we can still combine linear operations to make a new linear operation"
"And how could we run the same input through several operations? Have a row for each operation"

=====

2/28/16

taking a break, reading through various unrelated things for fun

https://www.toptal.com/aws/service-oriented-architecture-aws-lambda

TODO: i have no idea how makefiles work, should learn about how to write/use 'em one of these days

https://facebook.github.io/immutable-js/ neat
"the case for immutability" section a bit incoherent

http://tech.noredink.com/post/107617838018/switching-from-immutablejs-to-seamless-immutable

god, lots of reading today. forgot to paste a lot of the links i was looking at.

https://scott.mn/2014/01/20/reference_types_separate_identities_and_values/
atoms for beginners / nonclojurists

http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome

https://www.youtube.com/watch?v=MDZpSIngwm4
"single atom app state is good"

http://www.gamasutra.com/view/feature/3429/crashing_into_the_new_year_.php

******** GOOD ARTICLE ON COLLISION DETECTION
http://www.gamasutra.com/view/feature/3426/when_two_hearts_collide_.php
"The bounding box of the two objects clearly are colliding. It’s also just as clear that the objects
themselves are not. This is why being a human is great and being a game programmer is difficult."
"the game developer’s philosophy: "Do as much work up front as possible, especially if it saves run time.""

******** NOTE
"We assume that collision has not occurred and update the object’s position. If we find that a collision
has occurred, we move the object back and do not allow it to pass the boundary (or destroy it or take
some other preventative measure). However, this assumption is too simplistic because we don’t know if
the object’s previous position is still available. You’ll have to devise a scheme for what to do in this
case (otherwise, you’ll probably experience a crash or you’ll be stuck)"

on tunneling:
"An easy approach is to create a convex hull around an object’s location at two different times.
This approach is very inefficient and will definitely slow down your game. Instead of constructing
a convex hull, we could construct a bounding box around the solid."

"we can divide our world into objects that are stationary (collidees) and objects that move (colliders)
even with a v=0. For example, a rigid wall in a room is a collidee and a tennis ball thrown at the wall
is a collider. We can build two spatial trees (one for each group) out of these objects, and then check
which objects really have a chance of colliding. We can even restrict our environment further so that
some colliders won’t collide with each other — we don’t have to compute collisions between two bullets,
for example."

"In practice, these methods have manifested as octrees and axis-aligned bounding boxes (AABBs)"
"There are several ways to precompute OBBs, and they all involve a lot of math"

anyway current status is that i'm planning on just using dumb AABBs for collision detection
(if i even implement it myself! i'm mainly learning about all this stuff for fun, but expect to actually
end up just using some js library for this)

ok back to http://betterexplained.com/articles/linear-algebra-guide/
learning about matrices
[Operation Matrix] [Input Matrix]
[operation count x operation size] [input size x input count]
[m x n] [p x q] = [m x q]
[2 x 3] [3 x 2] = [2 x 2]
"Notice the matrices touch at the “size of operation” and “size of input” (n = p). They should match!
If our inputs have 3 components, our operations should expect 3 items. In fact, we can only multiply
matrices when n = p."

hm anyway i understand matrices *slightly* more but wouldn't say i have a firm handle on linear algebra.
would be worth doing the khan academy unit on it sometime
ok, anyway that's enough of that, let's go look for js collision detection libraries

hm i might have to implement something myself
something simple using SAT / AABBs

https://github.com/jriecken/sat-js relatively unused but perhaps a good learning aid

https://github.com/wellcaffeinated/PhysicsJS (unmaintained)

https://github.com/liabru/matter-js

https://github.com/liabru/matter-js/blob/master/src/collision/Detector.js super well commented

overall approach appears to be this series of passes:
1. quadtree or some other space partitioning method (broad test)
2. bounding-box tests (mid)
3. SAT test (narrow)

https://github.com/liabru/matter-js/blob/master/src/collision/SAT.js sat implementation

https://github.com/liabru/matter-js/blob/master/src/geometry/Bounds.js AABBs

https://github.com/kripken/box2d.js/ if i really want it (i don't)

actually you know what the blurb on https://www.ibm.com/developerworks/library/wa-build2dphysicsengine/
looks pretty good

"Sometimes, the complexity and overhead of a third-party physics library, such as Box2D, is overkill
for your JavaScript game"

that sure sounds like it's the case for me

here are the things i expect to build

collision detection
velocity/acceleration

here are the things i do *not* plan on including in the game

gravity
elastic collisions (eg bouncing off of things realistically) - you'll just come to a stop, not bounce off
  TODO: how will you come to a stop? immediately set velocity to 0 when you collide with a monster/wall?
    feels like there must be lots of edge cases there - what if monster runs straight at you? are you stuck to it?

all of the shapes in this game will be concave
there'll be rectangles, diamonds (obviously just rotated rectangles), spheres, ellipses
and that's it

ok i'll start on this tomorrow. will start by just doing something like

whenever an entity attempts to move:
for each other entity in the game that has a collision component: <----- TODO OPTIMIZE LATER VIA QUADTREES
compare AABBs to see if a collision happened
TODO eventually implement SAT for wavy obstacles / angled rectangles / etc

if moved entity collided with something, cancel its movement and fire a :contact message
if it didn't collide with anything, apply the movement (how? :update-event message?) and fire a :movement message

========

2/29/16

https://github.com/asciinema/asciinema-player uses phantom+doo, worth looking at when it comes time for tests

https://github.com/asciinema/asciinema-player/blob/master/src/cljs/asciinema_player/core.cljs#L31
good example of taking a ton of kwargs+defaults

he has two primary player implementations, "recorded" and "stream", and throughout core.cljs he has various
multimethods that have different implementations based on whether the player map they're operating on
is :recorded or :stream, interesting. this is basically how i'd expect people to use multimethods, but i haven't
seen them used often in the wild, people usually seem to favor protocols+records instead and i've
never been all that sure why (best guess: performance, better encapsulation?).

https://github.com/asciinema/asciinema-player/blob/master/src/cljs/asciinema_player/util.cljs#L6
is interesting, never seen/used js->clj before

tried it out, works like this:
(js->clj #js {:foo :bar} :keywordize-keys true)
{:foo :bar}

hella terminal command codes and shit in
https://github.com/asciinema/asciinema-player/blob/master/src/cljs/asciinema_player/vt.cljs

in https://github.com/asciinema/asciinema-player/commit/ab5aad1edde90f4a86e3ada80f8866e0b42d21d7
he solves a memory leak / cpu problem having to do with core.async
i have no idea how i'd go about doing that - the cpu i could diagnose via the profile tool, but memory?

http://ku1ik.com/2015/10/12/sweet-core-async.html

ok, i'm running into some issues when implementing the collision system

so basically, right now the plan was to have the movement system fire :intended-movement events whenever
a human- or ai-controlled entity wants to move somewhere, and the collision system listens for those events
and applies the new movement if the spot's clear, or rejects it and fires a :contact event if the spot's not clear.

and so in order for this to work, the collision systems needs to have access to the list of entities in the game
i suppose you could have the system keep a shadow list that basically mimics the master game state's list,
but that seems retarded.

and so the thing is that right now, there isn't a way for event handlers to get access to the state of the game.
they just get the event and a publish-chan.
well, can we pass it along in the event? i wonder

ok yeah i guess we really could

so here's what has to happen

the movement system's :reads field will be empty to indicate that it operates on the entire set of entities

the movement system then filters down so that it only operates on dudes with :intended-directions or whatever

and on each of those, it fires an :intended-movement event with fields :moved-entity, :all-entities

ok, that worked, collision detection is in.
so what next?

1) currently, the way collision detection works, you can't ever touch a wall - you can just get close to it,
    and then try to move closer to it and get denied, and so there's always a few pixels' gap.
    i suppose acceleration/deceleration would fix this, so on second thought let's just wait for that to go in.
2) if you touch a wall on your right, and try to move up+right, you stay still, you don't move up.

2) seems worth working on. what's the best way of fixing it?

we could emit N intended-movement events for player-controlled entities, one per held-down movement button.
that doesn't seem so bad, because only 1 entity would emit that many intended movement events, and you're
talking about a maximum of like 4.

maybe this should wait until after acceleration goes in, though, come to think of it, because that'll likely
change the whole movement situation pretty drastically.

ok so i guess there are two main next interesting things to work on

1) acceleration/velocities/etc
2) firing bullets

the second is obviously more immediately fun, so i'll probably start with that.

right first though i want to make x/y positions be the center of the shape

what needs to be modified for that to happen?

rendering system
collision system
level initialization

movement/input don't care though
